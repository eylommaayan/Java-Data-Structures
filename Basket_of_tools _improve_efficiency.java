public class Basket_of_tools _improve_efficiency {
    
}


/**
/**
 * החלפת משתנים עם משתנה עזר - 1
 * 
 * כלי עזר עבור מיון רשימה
 * חשוב לא להגדיר את המשתנה בתוך לולאה מפאת יעלות מקום כי כל פעם הוא יוגדר מחדש ואז יעילות המוקם תהיה של O(n) ולא של 1
//  int temp;
//  temp = arr[curr];
//  arr[curr] = arr[j];
//  arr[j] = temp;


 /**
 2- מעבר לניארי לאינדקס - נשתמש שאנחנו רוצים לסכום את כל המערך ואז להשתמש בסכום הזה כל פעם.

  השיטה הכי פשוטה - מעבר יחיד על מערך, בדרך כלל לא יהיה השיטה של התרגיל
   אלא כחלק מהתרגיל.
   for השימוש נעשה על ידי  מצביע אחד,  בדרך כלל בלולאת 
   בתוך הלולאה נעשה את הדרוש עלינו (נסכום, נחליף וכו)
   צריך לזכור שכמה מעברים סופיים על המערך שומר אל אותה יעילות.
   O(3n) = O(n)
   דוגמא: סכימת כל הערכים במערך
   n - יעלות
  */

for (int i =0; i< arr.length; i++) {
    if (arr[i] == 1)
        cnt++;
}


/**
מעבר לינארי של שני אינדקסים - בדרך כלל במערך ממוין 
 
 מאוזניים  O(n)

  יחידה  while ריצה עם שני אינדקסים אך עם לולאת
   (כדי שנוכל לעלות את הערכים כרצוננו) 
  שיטה מסובכת שמצריכה חשיבה מחוץ לקופסא אך נותנת לנו
  יעלות טובה עם טכניקה גבוהה
  דוגמא: מציאת תת מערך שסכומו 3 במערך ממוין עולה ממש
  n - יעילות
 * 
 * 
 *
 * 
 *  
 * int i = 0;
int j = arr.length -1;
while(i<j)
{
    if(sum ==3);
        breake; // הפסקת הלולאה אם סכום שווה ל-3
    else if (sum < 3)
    {
        sum -= arr[i]; // הוספת הערך של arr[i] לסכום
        i++
    }
}
System.out.println(i + " " + j);
 */


 /**
 * משתנים:

i מאתחל את תחילת המערך.
j מאתחל את סוף המערך.
sum הוא הסכום ההתחלתי (3).
לולאה:

הלולאה רצה כל עוד i קטן מ-j.
אם sum שווה ל-3, השבירה (break) תפסיק את הלולאה.
אם sum קטן מ-3, מתווסף הערך של arr[i] לסכום ו-i מוגדל ב-1.
אם sum גדול מ-3, מופחת הערך של arr[j] מהסכום ו-j מופחת ב-1.
הדפסת התוצאות:

הדפסת הערכים הסופיים של i ו-j.
 */



int i = 0;
int j = 1;
int sum =0
 while(j<arr.len)
{
    if(sum == 3);
        break;
    else if (sum < 3)
    {
        sum += arr[j];
        j++
    }
    else{
        sum -= arr[i]  // הפחתת הערך של arr[j] מהסכום
        i++  // הפחתת j ב-1
    }
}
System.out.println(i + " " + j);

